# GRPC 

[Synchronous gRPC Source](https://medium.com/@andrewvetovitz/grpc-c-introduction-45a66ca9461f)

[Async gRPC Source](https://grpc.io/docs/languages/cpp/async/)

## Table of Contents

* [Makefile](#the-makefile)
* [Synchronous gRPC](#synchronous-server-and-client)
* [Asynchronous gRPC](#asynchronous-server-and-client)

## The Makefile

[Makefile Docs](https://opensource.com/article/18/8/what-how-makefile)

When we first call `make` only the first target in a makefile is the default target. This means that `all` is the only target that will be run.

This command triggers a cascade of other commands in the file. Let's follow the chain.

1. `make` triggers the call of the target `all`.
2. `all` triggers the call of `clean`, then `client`, then `server`.
3. `clean` runs `rm` and deletes old things.

```Makefile
client: hello.pb.o hello.grpc.pb.o hello_grpc_client.o
$(CXX) $^ $(LDFLAGS) -o $@

%.grpc.pb.cc: %.proto
protoc --grpc_out=. --plugin=protoc-gen-grpc=$(GRPC_CPP_PLUGIN_PATH) $<

%.pb.cc: %.proto
protoc --cpp_out=. $<

```
4. `client` is where things start to get interesting. The entities following the `:` are **prerequisites**. The prerequisites are: `hello.pb.o hello.grpc.pb.o hello_grpc_client.o`. When make is asked to evaluate a rule, it begins by finding the files indicated by the prerequisites and target. **If any of the prerequisites has an associated rule, make attempts to update those first**. 
    1. The first prerequisite to be evaluated is `hello.pb.o`. Makefile understands how to create object files, it needs to run `hello.pb.cc` through the compilation process.

    <img src="compiler.png">

    2. The only problem is that `hello.pb.cc` doesn't exist! Luckily another make target exists that matches any files that match `%.pb.cc`. The entity before the `:`in a Makefile is known as the **target**. A Makfile contains recipes for creating the target. Thus because the makefile wants to create the `hello.pb.cc` file, it starts executing the `%.pb.cc` target.
    3. This target's prerequisite is `%.proto`, which because we want to create `hello.pb.cc`, matches to `hello.proto`. Yay! Finally a file that exists in our directory!
    4. Finally, the makefile starts to execute the rules of the target. Note that the `$<` syntax substitutes the prerequisite into the command.
    ```bash
    protoc --cpp_out=. hello.proto
    ```
    5. The invocation of the proto compiler yields the target file: `hello.pb.cc`. Hooray! Of course, now we need to yield the actual prerequisite of the `client` which is `hello.pb.o`. 
    6. Once the `hello.pb.cc` file is created, the makefile knows how to create an object file from it, it uses the c++ compiler.
    ```bash
    g++ -std=c++11 -I/usr/local/opt/openssl/include `pkg-config --cflags protobuf grpc`  -c -o hello.pb.o hello.pb.cc
    ```
    7. This yields the prerequisite for `client`, `hello.pb.o`. 
    8. From here the Makefile moves onto the next prerequisites, `hello.grpc.pb.o hello_grpc_client.o`, which follow a similar pattern. I won't walk through every step, but you should trace through the following output of the Makefile to make sure you understand what is happening. 
    ```bash
    protoc --grpc_out=. --plugin=protoc-gen-grpc=`which grpc_cpp_plugin` hello.proto
    g++ -std=c++11 -I/usr/local/opt/openssl/include `pkg-config --cflags protobuf grpc`  -c -o hello.grpc.pb.o hello.grpc.pb.cc
    g++ -std=c++11 -I/usr/local/opt/openssl/include `pkg-config --cflags protobuf grpc`  -c -o hello_grpc_client.o hello_grpc_client.cc
    g++ hello.pb.o hello.grpc.pb.o hello_grpc_client.o -L/usr/local/lib `pkg-config --libs protobuf grpc++` -o client
    rm hello.grpc.pb.cc hello.pb.cc
    ```
    9. Lastly, the Makefile will delete all the intermediary files generated through the compilation process. If you want to leave these files, you need to use the `PRECIOUS` directive.
5. The `server` command follows the same pattern as the client. 

## Synchronous Server and Client

The server and the client use code generated by the grpc c++ adapter. This code is generated during the `make` process detailed above.

The server is the more simple of the two, so let's address that first. 

In the server file we create a class that inherits from the C++-generated code from `hello.grpc.pb.h`. 

```c++
class HelloServiceImplementation final : public HelloService::Service {
    ...
}
```

This class definition states that the class `HelloServiceImplentation` will inherit from `HelloService::Service`, and that it cannot be used as the parent to another child class (this is what the `final` keyword means).

In this class we override the `sayHello` method that is auto-generated with the grpc compiler and implement it. We need to overwrite it because the compiler can have no way of knowing what we want this method to do. 

Lastly, we use the `serverBuilder` class from the grpc c++ library to instantiate an instance of our service and ask it to listen on port 5000 for client calls. 

The client is a little more complicated, although our setup is largely the same. We are going to implement a client class that utilizes dependencies created during proto compilation.

The two most important concepts to understand when looking at this code are **stubs and channels**. 

A stub is a piece of code that **converts parameters passed between client and server** during RPC. The client and server might use pointers to represent data, and of course those pointers won't make any sense on another computer, or perhaps the communicating computers might even use different data representations (big-endian vs little endian). Stubs provide a consistent translation layer between the services.

A channel is the abstraction provided by gRPC that represents the connection between the two services. Under the hood a channel is an HTTP/2 connection.

Let's look at some of the client code now: 

```c++
class HelloServiceClient {
    public:
        HelloServiceClient(std::shared_ptr<Channel> channel) : stub_(HelloService::NewStub(channel)) {}
    ...
    private:
        std::unique_ptr<HelloService::Stub> stub_;
```

The first thing to notice is the constructor, `HelloServiceClient`, this constructor takes as an argument a pointer to a channel. It inherits much of its functionality from the stub initializer, `stub_()`, which takes as an argument, the `HelloService::NewStub` method generated by the grpc compiler.

The `stub_` instance is initialized in the private section of the class. 

This class is utilized in the `Run` method, which initializes the connection between the client and the server. 

```c++
std::string address("0.0.0.0:5000");
HelloServiceClient client(
    grpc::CreateChannel(
        address,
        grpc::InsecureChannelCredentials()
    )
);

std::string response;

response = client.sendRequest(name);
```

Once this object is initialized, the private `stub_` instance can be utilized to send messages through the channel.

```c++
std::string sendRequest(std::string name) {
    Greeting request;
    request.set_name(name);
    GreetingResponse reply;
    ClientContext context;

    Status status = stub_->sayHello(&context, request, &reply);

    if (status.ok()) {
        return reply.message();
    } else {
        std::cout << status.error_code() << ": " << status.error_message() << std::endl;
        return " :( There was an error sending your greeting";
    }
}
```

## Asynchronous Server and Client

The asynchronous server and client are more complicated than the synchronous versions. They do however follow the same basic behavior.

Let's start with the client. It follows the same API that the synchronous client follows. 

```c++
class HelloServiceClient {
    public:
        HelloServiceClient(std::shared_ptr<Channel> channel) : stub_(HelloService::NewStub(channel)) {}
    private:
        std::unique_ptr<HelloService::Stub> stub_;
```

The big difference is in the `sendRequest` method.

```c++
std::string sendRequest(std::string name) {
        Greeting request;
        request.set_name(name);

        GreetingResponse reply;
        ClientContext context;
        CompletionQueue cq;
        Status status;

        std::unique_ptr<ClientAsyncResponseReader<GreetingResponse> > rpc(stub_->PrepareAsyncsayHello(&context, request, &cq));

        rpc->StartCall();

        rpc->Finish(&reply, &status, (void*)1);
        void* got_tag;

        bool ok = false;

        GPR_ASSERT(cq.Next(&got_tag, &ok));
        
        GPR_ASSERT(got_tag == (void*)1);

        GPR_ASSERT(ok);

        if (status.ok()) {
            return reply.message();
        } else {
            std::cout << status.error_code() << ": " << status.error_message() << std::endl;
            return " :( There was an error sending your greeting";
        }
    }
```

Instead of just using the `sayHello` method from the stub, we need to initialize the `rpc` object, which is an interface with the **completion queue**, the main point of interaction between asynchronous client and server. The client puts requests onto the queue, the server takes them off, services them, and then puts the response back onto the queue for the client to consume.

The `rpc` object is an instance of the `ClientAsyncResponseReader`, a grpc class that helps to initiate the request and read for the response of type `GreetingResponse`.

There are three important interactions with this object.

1. The initialization of the object.
    * `std::unique_ptr<ClientAsyncResponseReader<GreetingResponse> > rpc(stub_->PrepareAsyncsayHello(&context, request, &cq));`
2. The invocation of the request.
    * `rpc->StartCall();`
3. The retrieval of the response from the completion queue.
    * `rpc->Finish(&reply, &status, (void*)1); `

The initialization of the async object does not actually send the request, this is done through the `StartCall()` function. 

The `Finish()` function is not a blocking call. It is a request to receive the server's response msg and final status into the data structures passed to it, as well as to notify the tag on the client's completion queue when the server is finished.

The blocking call on the client is `cq.Next(),`, which waits for the completion queue to return the tag passed into the `Finish()` call. Once this tag is returned, the reply and status will be ready.

Long story short, the client initializes a connection with the server, and then sets up a completion queue that it polls for responses from the server. 

Let's now take a look at the Async server. This implementation is even more dramatically different. Remember in the synchronous server we needed to initialize an instance of the server that inherits from the GRPC-initialized code. We do the same here. 