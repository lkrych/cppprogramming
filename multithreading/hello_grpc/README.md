# GRPC 

[Synchronous gRPC Source](https://medium.com/@andrewvetovitz/grpc-c-introduction-45a66ca9461f)

[Async gRPC Source](https://grpc.io/docs/languages/cpp/async/)

## Table of Contents

* [Makefile](#the-makefile)
* [Synchronous gRPC](#synchronous-server-and-client)
* [Asynchronous gRPC](#asynchronous-server-and-client)

## The Makefile

[Makefile Docs](https://opensource.com/article/18/8/what-how-makefile)

When we first call `make` only the first target in a makefile is the default target. This means that `all` is the only target that will be run.

This command triggers a cascade of other commands in the file. Let's follow the chain.

1. `make` triggers the call of the target `all`.
2. `all` triggers the call of `clean`, then `client`, then `server`.
3. `clean` runs `rm` and deletes old things.

```Makefile
client: hello.pb.o hello.grpc.pb.o hello_grpc_client.o
$(CXX) $^ $(LDFLAGS) -o $@

%.grpc.pb.cc: %.proto
protoc --grpc_out=. --plugin=protoc-gen-grpc=$(GRPC_CPP_PLUGIN_PATH) $<

%.pb.cc: %.proto
protoc --cpp_out=. $<

```
4. `client` is where things start to get interesting. The entities following the `:` are **prerequisites**. The prerequisites are: `hello.pb.o hello.grpc.pb.o hello_grpc_client.o`. When make is asked to evaluate a rule, it begins by finding the files indicated by the prerequisites and target. **If any of the prerequisites has an associated rule, make attempts to update those first**. 
    1. The first prerequisite to be evaluated is `hello.pb.o`. Makefile understands how to create object files, it needs to run `hello.pb.cc` through the compilation process.

    <img src="compiler.png">

    2. The only problem is that `hello.pb.cc` doesn't exist! Luckily another make target exists that matches any files that match `%.pb.cc`. The entity before the `:`in a Makefile is known as the **target**. A Makfile contains recipes for creating the target. Thus because the makefile wants to create the `hello.pb.cc` file, it starts executing the `%.pb.cc` target.
    3. This target's prerequisite is `%.proto`, which because we want to create `hello.pb.cc`, matches to `hello.proto`. Yay! Finally a file that exists in our directory!
    4. Finally, the makefile starts to execute the rules of the target. Note that the `$<` syntax substitutes the prerequisite into the command.
    ```bash
    protoc --cpp_out=. hello.proto
    ```
    5. The invocation of the proto compiler yields the target file: `hello.pb.cc`. Hooray! Of course, now we need to yield the actual prerequisite of the `client` which is `hello.pb.o`. 
    6. Once the `hello.pb.cc` file is created, the makefile knows how to create an object file from it, it uses the c++ compiler.
    ```bash
    g++ -std=c++11 -I/usr/local/opt/openssl/include `pkg-config --cflags protobuf grpc`  -c -o hello.pb.o hello.pb.cc
    ```
    7. This yields the prerequisite for `client`, `hello.pb.o`. 
    8. From here the Makefile moves onto the next prerequisites, `hello.grpc.pb.o hello_grpc_client.o`, which follow a similar pattern. I won't walk through every step, but you should trace through the following output of the Makefile to make sure you understand what is happening. 
    ```bash
    protoc --grpc_out=. --plugin=protoc-gen-grpc=`which grpc_cpp_plugin` hello.proto
    g++ -std=c++11 -I/usr/local/opt/openssl/include `pkg-config --cflags protobuf grpc`  -c -o hello.grpc.pb.o hello.grpc.pb.cc
    g++ -std=c++11 -I/usr/local/opt/openssl/include `pkg-config --cflags protobuf grpc`  -c -o hello_grpc_client.o hello_grpc_client.cc
    g++ hello.pb.o hello.grpc.pb.o hello_grpc_client.o -L/usr/local/lib `pkg-config --libs protobuf grpc++` -o client
    rm hello.grpc.pb.cc hello.pb.cc
    ```
    9. Lastly, the Makefile will delete all the intermediary files generated through the compilation process. If you want to leave these files, you need to use the `PRECIOUS` directive.
5. The `server` command follows the same pattern as the client. 

## Synchronous Server and Client

The server and the client use code generated by the grpc c++ adapter. This code is generated during the `make` process detailed above.

The server is the more simple of the two, so let's address that first. 

In the server file we create a class that inherits from the C++-generated code from `hello.grpc.pb.h`. 

```c++
class HelloServiceImplementation final : public HelloService::Service {
    ...
}
```

This class definition states that the class `HelloServiceImplentation` will inherit from `HelloService::Service`, and that it cannot be used as the parent to another child class (this is what the `final` keyword means).

In this class we override the `sayHello` method that is auto-generated with the grpc compiler and implement it. We need to overwrite it because the compiler can have no way of knowing what we want this method to do. 

Lastly, we use the `serverBuilder` class from the grpc c++ library to instantiate an instance of our service and ask it to listen on port 5000 for client calls. 

The client is a little more complicated, although our setup is largely the same. We are going to implement a client class that utilizes dependencies created during proto compilation.

The two most important concepts to understand when looking at this code are **stubs and channels**. 

A stub is a piece of code that **converts parameters passed between client and server** during RPC. The client and server might use pointers to represent data, and of course those pointers won't make any sense on another computer, or perhaps the communicating computers might even use different data representations (big-endian vs little endian). Stubs provide a consistent translation layer between the services.

A channel is the abstraction provided by gRPC that represents the connection between the two services. Under the hood a channel is an HTTP/2 connection.

Let's look at some of the client code now: 

```c++
class HelloServiceClient {
    public:
        HelloServiceClient(std::shared_ptr<Channel> channel) : stub_(HelloService::NewStub(channel)) {}
    ...
    private:
        std::unique_ptr<HelloService::Stub> stub_;
```

The first thing to notice is the constructor, `HelloServiceClient`, this constructor takes as an argument a pointer to a channel. It inherits much of its functionality from the stub initializer, `stub_()`, which takes as an argument, the `HelloService::NewStub` method generated by the grpc compiler.

The `stub_` instance is initialized in the private section of the class. 

This class is utilized in the `Run` method, which initializes the connection between the client and the server. 

```c++
std::string address("0.0.0.0:5000");
HelloServiceClient client(
    grpc::CreateChannel(
        address,
        grpc::InsecureChannelCredentials()
    )
);

std::string response;

response = client.sendRequest(name);
```

Once this object is initialized, the private `stub_` instance can be utilized to send messages through the channel.

```c++
std::string sendRequest(std::string name) {
    Greeting request;
    request.set_name(name);
    GreetingResponse reply;
    ClientContext context;

    Status status = stub_->sayHello(&context, request, &reply);

    if (status.ok()) {
        return reply.message();
    } else {
        std::cout << status.error_code() << ": " << status.error_message() << std::endl;
        return " :( There was an error sending your greeting";
    }
}
```

## Asynchronous Server and Client

The asynchronous server and client are more complicated than the synchronous versions. They do however follow the same basic behavior.

Let's start with the client. It follows the same API that the synchronous client follows. 

```c++
class HelloServiceClient {
    public:
        HelloServiceClient(std::shared_ptr<Channel> channel) : stub_(HelloService::NewStub(channel)) {}
    private:
        std::unique_ptr<HelloService::Stub> stub_;
```

The big difference is in the `sendRequest` method.

```c++
std::string sendRequest(std::string name) {
        Greeting request;
        request.set_name(name);

        GreetingResponse reply;
        ClientContext context;
        CompletionQueue cq;
        Status status;

        std::unique_ptr<ClientAsyncResponseReader<GreetingResponse> > rpc(stub_->PrepareAsyncsayHello(&context, request, &cq));

        rpc->StartCall();

        rpc->Finish(&reply, &status, (void*)1);
        void* got_tag;

        bool ok = false;

        GPR_ASSERT(cq.Next(&got_tag, &ok));
        
        GPR_ASSERT(got_tag == (void*)1);

        GPR_ASSERT(ok);

        if (status.ok()) {
            return reply.message();
        } else {
            std::cout << status.error_code() << ": " << status.error_message() << std::endl;
            return " :( There was an error sending your greeting";
        }
    }
```

Instead of just using the `sayHello` method from the stub, we need to initialize the `rpc` object, which is an interface with the **completion queue**, the main point of interaction between asynchronous client and server. The client puts requests onto the queue, the server takes them off, services them, and then puts the response back onto the queue for the client to consume.

The `rpc` object is an instance of the `ClientAsyncResponseReader`, a grpc class that helps to initiate the request and read for the response of type `GreetingResponse`.

There are three important interactions with this object.

1. The initialization of the object.
    * `std::unique_ptr<ClientAsyncResponseReader<GreetingResponse> > rpc(stub_->PrepareAsyncsayHello(&context, request, &cq));`
2. The invocation of the request.
    * `rpc->StartCall();`
3. The retrieval of the response from the completion queue.
    * `rpc->Finish(&reply, &status, (void*)1); `

The initialization of the async object does not actually send the request, this is done through the `StartCall()` function. 

The `Finish()` function is not a blocking call. It is a request to receive the server's response msg and final status into the data structures passed to it, as well as to notify the tag on the client's completion queue when the server is finished.

The blocking call on the client is `cq.Next(),`, which waits for the completion queue to return the tag passed into the `Finish()` call. Once this tag is returned, the reply and status will be ready.

Long story short, the client initializes a connection with the server, and then sets up a completion queue that it polls for responses from the server. 

Let's now take a look at the Async server. This implementation is even more dramatically different than it's synchronous cousin. Remember in the synchronous server we needed to initialize an instance of the server that inherits from the GRPC-initialized code. We do the same here, but this time we export an Asynchronous service.

The class we are constructing is called `AsyncServer`. It has one public function, `Run()`, and one private function, `HandleRpcs()`. `Run` is used to initialize the server and to put it into the main serving loop. `HandleRpcs` is the main server loop. Let's look at each of these functions in turn.

The server also has a few fields that it maintains.

```c++
std::unique_ptr<ServerCompletionQueue> cq_;
HelloService::AsyncService service_;
std::unique_ptr<Server> server_;
```

The completion queue will look familiar, it is the data structure used to manage the incoming requests to the server. The `service_` instance is used to calling GRPC-constructed methods. The `server_` field is used to maintain a reference to the server instance so that it can be deconstructed properly.

```c++
void Run() {
    std::string server_address("0.0.0.0:5000");

    ServerBuilder builder;

    builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
    
    //Register service_ as the instance we'll communicate with the clients
    builder.RegisterService(&service_);

    //Get ahold of the completion queue used for Async communication with
    // the grpc runtime
    cq_ = builder.AddCompletionQueue();
    // Assemble the server
    server_ = builder.BuildAndStart();
    std::cout << "Server listening on " << server_address << std::endl;

    // Proceed to server's main loop.
    HandleRpcs();
}
```

The instantiation of the asynchronous service happens in the `Run()` method on the AsyncServer class. In this method the ServerBuilder helper function from GRPC is used to establish the listening function of the service and initialize the completion queue. Once this is done, the server enters its main loop, `HandleRpcs()`.

```c++
void HandleRpcs() {
    //spawn a new CallData instance to serve new clients.
    new CallData(&service_, cq_.get());
    void* tag; //uniquely identifies a request 
    bool ok;
    while (true) {
        // Block waiting to read the next event from the completion queue.
        // The event is uniquely identified by its tag, which in this case is the 
        // memory address of the CallData instance.
        // The return value of Next should always be checked. This value tells us whether
        // there is any kind of event or cq_ is shutting down
        GPR_ASSERT(cq_->Next(&tag, &ok));
        GPR_ASSERT(ok);
        static_cast<CallData*>(tag)->Proceed();
    }
}
```

The purpose of the `HandleRpcs()` function is to provide a method for querying the shared completion queue. In the method, the server creates a new data structure, the CallData object to maintain the state of each asynchronous RPC request so that the server can handle multiple requests concurrently. The CallData object is initialized with a reference to the service and the completion queue instance being used by the service. Once a request has been received, it is used to invoke the CallData state machine that manages request processing.

All of the logic for handling a request is encapsulated inside the CallData object. Let's take a look at how that works. 

```c++
class CallData {
    public:
        // Take in the "service" instance (the async server) and the completion queue
        CallData(HelloService::AsyncService* service, ServerCompletionQueue* cq) :
        service_(service), cq_(cq), responder_(&ctx_), status_(CREATE) {
            //Invoke the serving logic 
            Proceed();
        }
     private:
        HelloService::AsyncService* service_;

        ServerCompletionQueue* cq_;

        ServerContext ctx_;

        Greeting request_;

        GreetingResponse reply_;

        ServerAsyncResponseWriter<GreetingResponse> responder_;

        enum CallStatus { CREATE, PROCESS, FINISH };
        CallStatus status_;
``` 

The constructor takes two arguments, the service instance and the completion queue instance. Notice that it also has a `:` after the arguments. This is used for **initializing member fields before the body of the constructor executes**. This ensures that all the necessary fields are set before the `Proceed()` member function is called.

```c++
void Proceed() {
    if (status_ == CREATE) {
        status_ = PROCESS;
        // As part of the initial CREATE state, we request that the system 
        // start processing SayHello requests. In this request, "this" acts as 
        // the taq uniquely identifying the request (so that different CallData instances
        // can serve different requests concurrently), in this case the tag is the memory address
        // of the CallData instance
        service_->RequestsayHello(&ctx_, &request_, &responder_, cq_, cq_, this);
    } else if (status_ == PROCESS) {
        // Spawn a new CallData instance to serve new clients while we process
        // the one for this CallData. The instance will deallocate itself
        new CallData(service_, cq_);

        //the actual processing!
        std::string prefix("Hello ");
        reply_.set_message(prefix + request_.name());

        // let the gRPC runtime know we've finished using the memory
        // address of this instance as the tag for the event
        status_ = FINISH;
        responder_.Finish(reply_, Status::OK, this);
    } else {
        GPR_ASSERT(status_ == FINISH);
        // Once in the FINISH state, deallocate CallData
        delete this;
    }
}
```

