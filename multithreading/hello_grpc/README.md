# GRPC 

[Synchronous gRPC Source](https://medium.com/@andrewvetovitz/grpc-c-introduction-45a66ca9461f)

[Async gRPC Source](https://grpc.io/docs/languages/cpp/async/)

## Table of Contents

* [Makefile](#the-makefile)

## The Makefile

[Makefile Docs](https://opensource.com/article/18/8/what-how-makefile)

When we first call `make` only the first target in a makefile is the default target. This means that `all` is the only target that will be run.

This command triggers a cascade of other commands in the file. Let's follow the chain.

1. `make` triggers the call of the target `all`.
2. `all` triggers the call of `clean`, then `client`, then `server`.
3. `clean` runs `rm` and deletes old things.

```Makefile
client: hello.pb.o hello.grpc.pb.o hello_grpc_client.o
$(CXX) $^ $(LDFLAGS) -o $@

%.grpc.pb.cc: %.proto
protoc --grpc_out=. --plugin=protoc-gen-grpc=$(GRPC_CPP_PLUGIN_PATH) $<

%.pb.cc: %.proto
protoc --cpp_out=. $<

```
4. `client` is where things start to get interesting. The entities following the `:` are **prerequisites**. The prerequisites are: `hello.pb.o hello.grpc.pb.o hello_grpc_client.o`. When make is asked to evaluate a rule, it begins by finding the files indicated by the prerequisites and target. **If any of the prerequisites has an associated rule, make attempts to update those first**. 
    1. The first prerequisite to be evaluated is `hello.pb.o`. Makefile understands how to create object files, it needs to run `hello.pb.cc` through the compilation process.

    <img src="compiler.png">

    2. The only problem is that `hello.pb.cc` doesn't exist! Luckily another make target exists that matches any files that match `%.pb.cc`. The entity before the `:`in a Makefile is known as the **target**. A Makfile contains recipes for creating the target. Thus because the makefile wants to create the `hello.pb.cc` file, it starts executing the `%.pb.cc` target.
    3. This target's prerequisite is `%.proto`, which because we want to create `hello.pb.cc`, matches to `hello.proto`. Yay! Finally a file that exists in our directory!
    4. Finally, the makefile starts to execute the rules of the target. Note that the `$<` syntax substitutes the prerequisite into the command.
    ```bash
    protoc --cpp_out=. hello.proto
    ```
    5. The invocation of the proto compiler yields the target file: `hello.pb.cc`. Hooray! Of course, now we need to yield the actual prerequisite of the `client` which is `hello.pb.o`. 
    6. Once the `hello.pb.cc` file is created, the makefile knows how to create an object file from it, it uses the c++ compiler.
    ```bash
    g++ -std=c++11 -I/usr/local/opt/openssl/include `pkg-config --cflags protobuf grpc`  -c -o hello.pb.o hello.pb.cc
    ```
    7. This yields the prerequisite for `client`, `hello.pb.o`. 
    8. From here the Makefile moves onto the next prerequisites, `hello.grpc.pb.o hello_grpc_client.o`, which follow a similar pattern. I won't walk through every step, but you should trace through the following output of the Makefile to make sure you understand what is happening. 
    ```bash
    protoc --grpc_out=. --plugin=protoc-gen-grpc=`which grpc_cpp_plugin` hello.proto
    g++ -std=c++11 -I/usr/local/opt/openssl/include `pkg-config --cflags protobuf grpc`  -c -o hello.grpc.pb.o hello.grpc.pb.cc
    g++ -std=c++11 -I/usr/local/opt/openssl/include `pkg-config --cflags protobuf grpc`  -c -o hello_grpc_client.o hello_grpc_client.cc
    g++ hello.pb.o hello.grpc.pb.o hello_grpc_client.o -L/usr/local/lib `pkg-config --libs protobuf grpc++` -o client
    rm hello.grpc.pb.cc hello.pb.cc
    ```
    9. Lastly, the Makefile will delete all the intermediary files generated through the compilation process. If you want to leave these files, you need to use the `PRECIOUS` directive.
5. The `server` command follows the same pattern as the client. 

## Synchronous Server and Client

The server and the client use code generated by the grpc c++ adapter. This code is generated during the `make` process detailed above.

The server is the more simple of the two, so let's address that first. 

In the server file we create a class that inherits from the C++-generated code from `hello.grpc.pb.h`. 

```c++
class HelloServiceImplementation final : public HelloService::Service {
    ...
}
```

This class definition states that the class `HelloServiceImplentation` will inherit from `HelloService::Service`, and that it cannot be used as the parent to another child class (this is what the `final` keyword means).

In this class we override the `sayHello` method that is auto-generated with the grpc compiler and implement it. We need to overwrite it because the compiler can have no way of knowing what we want this method to do. 

Lastly, we use the `serverBuilder` class from the grpc c++ library to instantiate an instance of our service and ask it to listen on port 5000 for client calls. 

The client is a little more complicated, although our setup is largely the same. We are going to implement a client class that utilizes dependencies created during proto compilation.

The two most important concepts to understand when looking at this code are **stubs and channels**. 

A stub is a piece of code that **converts parameters passed between client and server** during RPC. The client and server might use pointers to represent data, and of course those pointers won't make any sense on another computer, or perhaps the communicating computers might even use different data representations (big-endian vs little endian). Stubs provide a consistent translation layer between the services.

A channel is the abstraction provided by gRPC that represents the connection between the two services. Under the hood a channel is an HTTP/2 connection.

Let's look at some of the client code now: 

```c++
class HelloServiceClient {
    public:
        HelloServiceClient(std::shared_ptr<Channel> channel) : stub_(HelloService::NewStub(channel)) {}
    ...
    private:
        std::unique_ptr<HelloService::Stub> stub_;
```

The first thing to notice is the constructor, `HelloServiceClient`, this constructor takes as an argument a pointer to a channel. It inherits much of its functionality from the stub initializer, `stub_()`, which takes as an argument, the `HelloService::NewStub` method generated by the grpc compiler.

The `stub_` instance is initialized in the private section of the class. 

This class is utilized in the `Run` method, which initializes the connection between the client and the server. 

```c++
std::string address("0.0.0.0:5000");
HelloServiceClient client(
    grpc::CreateChannel(
        address,
        grpc::InsecureChannelCredentials()
    )
);

std::string response;

response = client.sendRequest(name);
```